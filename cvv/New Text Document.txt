#addition
import cv2
import numpy as np
image1 = cv2.imread('image1.jpg')
image2 = cv2.imread('image2.jpg')
image2 = cv2.resize(image2, (image1.shape[1], image1.shape[0]))
addition_result = cv2.add(image1, image2)
subtraction_result = cv2.subtract(image1, image2)
multiplication_result = cv2.multiply(image1, image2)
epsilon = 1e-5
division_result = cv2.divide(image1, image2 + epsilon)
difference_result = cv2.absdiff(image1, image2)
cv2.imshow('Addition Result', addition_result)
cv2.imshow('Subtraction Result', subtraction_result)
cv2.imshow('Multiplication Result', multiplication_result)
cv2.imshow('Division Result', division_result)
cv2.imshow('Difference Result', difference_result)
cv2.waitKey(0)
cv2.destroyAllWindows()

#harris
import cv2
import numpy as np
image = cv2.imread('img.jpg')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
dst = cv2.cornerHarris(gray_image, 2, 3, 0.04)
dst = cv2.dilate(dst, None)
threshold = 0.01 * dst.max()
result = image.copy()
result[dst > threshold] = [0, 0, 255]
cv2.imshow('Harris Corners Detected', result)
cv2.waitKey(0)
cv2.destroyAllWindows()

#gray-number
import cv2
import numpy as np
gray_image = cv2.imread('input_gray.jpg',cv2.IMREAD_GRAYSCALE)
if gray_image is not None:
    gray_values = gray_image.tolist()
    gray_array = np.array(gray_values)
    print("Grayscale image converted to array:")
    print(gray_array)
else:
    print("Error: Could not load the image.")

#number-gray
import numpy as np
import cv2
arr = np.array([[100, 200, 500],
                [150, 750, 120],
                [800, 300, 170]])
arr_normalized = cv2.normalize(arr, None, alpha=0, beta
255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
gray_image = cv2.cvtColor(arr_normalized, cv2.COLOR_GRAY2BGR)
cv2.imshow('Grayscale Image', gray_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

#olw
import cv2
import numpy as np

# Load the image
image = cv2.imread('car.jpg', cv2.IMREAD_GRAYSCALE)

# Ensure the image loaded successfully
if image is None:
    print("Image not found")
    exit()

# Perform the logarithmic transformation
log_transformed = np.power(image/255.0, 5) * 255.0

# Normalize the values to the range [0, 255]
log_transformed = cv2.normalize(log_transformed, None, 0, 255, cv2.NORM_MINMAX)

# Define the window width and level values
window_width = 40  # Adjust this value as needed
window_level = 50  # Adjust this value as needed

# Calculate the minimum and maximum values of the window
min_value = window_level - window_width // 2
max_value = window_level + window_width // 2

# Clip pixel values to the window range
windowed_image = np.clip(image, min_value, max_value)

# Normalize the windowed image to the 0-255 range
windowed_image = cv2.normalize(windowed_image, None, 0, 255, cv2.NORM_MINMAX)

# Convert the data type to unsigned 8-bit integer (0-255)
windowed_image = windowed_image.astype(np.uint8)

# Display the original, logarithmically transformed, and windowed images
cv2.imshow('Original Image', image)
cv2.imshow('Logarithmic Transformation', log_transformed)
cv2.imshow('Windowed Image', windowed_image)

cv2.waitKey(0)
cv2.destroyAllWindows()

#from user
import cv2
import numpy as np

# Ask for the image width and height
width = int(input("Enter image width: "))
height = int(input("Enter image height: "))

# Create a black image with the specified width and height
image = np.zeros((height, width, 3), dtype=np.uint8)

# Define the size of the corner rectangles
corner_size = 30

# Create white rectangles at the four corners
image[:corner_size, :corner_size] = (255, 255, 255)  # Top-left corner
image[:corner_size, -corner_size:] = (255, 255, 255)  # Top-right corner
image[-corner_size:, :corner_size] = (255, 255, 255)  # Bottom-left corner
image[-corner_size:, -corner_size:] = (255, 255, 255)  # Bottom-right corner

# Display the resulting image
cv2.imshow("Image with Four White Corners", image)
cv2.waitKey(0)
cv2.destroyAllWindows()
import cv2
import numpy as np

# Ask for the image width and height
width = int(input("Enter image width: "))
height = int(input("Enter image height: "))

# Create a black image with the specified width and height
image = np.zeros((height, width, 3), dtype=np.uint8)

# Draw vertical and horizontal lines
line_thickness = 2

# Draw vertical line in the center
cv2.line(image, (width // 2, 0), (width // 2, height), (255, 255, 255), line_thickness)
cv2.line(image, (width // 4, 0), (width // 4, height), (255, 255, 255), line_thickness)
cv2.line(image, (width // 6, 0), (width // 6, height), (255, 255, 255), line_thickness)
cv2.line(image, (width // 8, 0), (width // 8, height), (255, 255, 255), line_thickness)

# Draw horizontal line in the center
cv2.line(image, (0, height // 2), (width, height // 2), (255, 255, 255), line_thickness)
cv2.line(image, (0, height // 2), (width, height // 2), (255, 255, 255), line_thickness)
cv2.line(image, (0, height // 2), (width, height // 2), (255, 255, 255), line_thickness)
cv2.line(image, (0, height // 2), (width, height // 2), (255, 255, 255), line_thickness)

# Display the resulting image
cv2.imshow("Image with Vertical and Horizontal Lines", image)
cv2.waitKey(0)
cv2.destroyAllWindows()
import numpy as np

# Ask for the image width and height
width = int(input("Enter image width: "))
height = int(input("Enter image height: "))

# Create a black image with the specified width and height
image = np.zeros((height, width, 3), dtype=np.uint8)

# Create a white rectangle in the center
cv2.rectangle(image, (width // 4, height // 4), (3 * width // 4, 3 * height // 4), (255, 255, 255), -1)

# Display the resulting image
cv2.imshow("Black Image with White Area", image)
cv2.waitKey(0)
cv2.destroyAllWindows()


#pose

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow
BODY_PARTS = { "Nose": 0, "Neck": 1, "RShoulder": 2, "RElbow": 3, "RWrist": 4,
"LShoulder": 5, "LElbow": 6, "LWrist": 7, "RHip": 8, "RKnee": 9,
"RAnkle": 10, "LHip": 11, "LKnee": 12, "LAnkle": 13, "REye": 14,
"LEye": 15, "REar": 16, "LEar": 17, "Background": 18 }
POSE_PAIRS = [ ["Neck", "RShoulder"], ["Neck", "LShoulder"], ["RShoulder", "RElbow"],
["RElbow", "RWrist"], ["LShoulder", "LElbow"], ["LElbow", "LWrist"],
["Neck", "RHip"], ["RHip", "RKnee"], ["RKnee", "RAnkle"], ["Neck", "LHip"],
["LHip", "LKnee"], ["LKnee", "LAnkle"], ["Neck", "Nose"], ["Nose", "REye"],
["REye", "REar"], ["Nose", "LEye"], ["LEye", "LEar"] ]
width = 368
height = 368
inWidth = width
inHeight = height
net = cv.dnn.readNetFromTensorflow("graph_opt.pb")
thr = 0.2
def poseDetector(frame):
frameWidth = frame.shape[1]
frameHeight = frame.shape[0]
net.setInput(cv.dnn.blobFromImage(frame, 1.0, (inWidth, inHeight), (127.5, 127.5, 127.5),
swapRB=True, crop=False))
out = net.forward()
out = out[:, :19, :, :] # MobileNet output [1, 57, -1, -1], we only need the first 19 elements
assert(len(BODY_PARTS) == out.shape[1])
points = []
for i in range(len(BODY_PARTS)):
# Slice heatmap of corresponging body's part.
heatMap = out[0, i, :, :]
_, conf, _, point = cv.minMaxLoc(heatMap)
x = (frameWidth * point[0]) / out.shape[3]
y = (frameHeight * point[1]) / out.shape[2]
points.append((int(x), int(y)) if conf > thr else None:
for pair in POSE_PAIRS:
partFrom = pair[0]
partTo = pair[1]
assert(partFrom in BODY_PARTS)
assert(partTo in BODY_PARTS)
idFrom = BODY_PARTS[partFrom]
idTo = BODY_PARTS[partTo]
if points[idFrom] and points[idTo]:
cv.line(frame, points[idFrom], points[idTo], (0, 255, 0), 3)
cv.ellipse(frame, points[idFrom], (3, 3), 0, 0, 360, (0, 0, 255), cv.FILLED)
cv.ellipse(frame, points[idTo], (3, 3), 0, 0, 360, (0, 0, 255), cv.FILLED)
t, _ = net.getPerfProfile()
return frame
input = cv.imread("/content/jhon.jpg")
output = poseDetector(input)
cv2_imshow(output)